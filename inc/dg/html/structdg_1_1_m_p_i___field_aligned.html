<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Discontinuous Galerkin Library: dg::MPI_FieldAligned&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="tablist"> 
      <li><a href="../../../index.html">/</a><li>
    <li><a href="../../../inc/dg/html/index.html">DG lib</a></li>
    <li><a href="../../../inc/file/html/index.html">FILE lib</a></li>
    <li><a href="../../../inc/toefl/html/index.html">TOEFL lib</a></li>
    <li><a href="../../../inc/geometries/html/index.html">GEOMETRY lib</a></li>
    <li><a href="../../../src/feltor/html/index.html">FELTOR code</a></li>
    <li><a href="../../../src/feltor2D/html/index.html">FELTOR2D code</a></li>
    <li><a href="../../../src/innto/html/index.html">INNTO code</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Discontinuous Galerkin Library
   &#160;<span id="projectnumber">3.0</span>
   </div>
   <div id="projectbrief">Discontinuous Galerkin numerical methods and container free numerical algorithms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structdg_1_1_m_p_i___field_aligned.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1_m_p_i___field_aligned-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dg::MPI_FieldAligned&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group___d_g.html">The Discontinuous Galerkin library</a> &raquo; <a class="el" href="group__algorithms.html">Numerical schemes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for the evaluation of a parallel derivative (MPI Version)  
 <a href="structdg_1_1_m_p_i___field_aligned.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mpi__fieldaligned_8h_source.html">mpi_fieldaligned.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a28ebee51e0decb692933a38363dca3f2"><td class="memTemplParams" colspan="2">template&lt;class Field , class Limiter &gt; </td></tr>
<tr class="memitem:a28ebee51e0decb692933a38363dca3f2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html#a28ebee51e0decb692933a38363dca3f2">MPI_FieldAligned</a> (Field field, Geometry <a class="el" href="structdg_1_1_m_p_i___field_aligned.html#abeec60a06ae03211c2eaae8d6c359589">grid</a>, double eps=1e-4, Limiter limit=DefaultLimiter(), dg::bc globalbcz=dg::DIR, double deltaPhi=-1)</td></tr>
<tr class="memdesc:a28ebee51e0decb692933a38363dca3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a field and a grid.  <a href="#a28ebee51e0decb692933a38363dca3f2">More...</a><br /></td></tr>
<tr class="separator:a28ebee51e0decb692933a38363dca3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82d1728dc5a9a86919dd2ec5f1f04bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html#ac82d1728dc5a9a86919dd2ec5f1f04bd">set_boundaries</a> (<a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, double left, double right)</td></tr>
<tr class="memdesc:ac82d1728dc5a9a86919dd2ec5f1f04bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions.  <a href="#ac82d1728dc5a9a86919dd2ec5f1f04bd">More...</a><br /></td></tr>
<tr class="separator:ac82d1728dc5a9a86919dd2ec5f1f04bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedbdcbfbeaf5b1fd8635061451d5846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html#afedbdcbfbeaf5b1fd8635061451d5846">set_boundaries</a> (<a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;left, const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;right)</td></tr>
<tr class="memdesc:afedbdcbfbeaf5b1fd8635061451d5846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions.  <a href="#afedbdcbfbeaf5b1fd8635061451d5846">More...</a><br /></td></tr>
<tr class="separator:afedbdcbfbeaf5b1fd8635061451d5846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8dd803bd3438778440824a5a376e6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html#aac8dd803bd3438778440824a5a376e6e">set_boundaries</a> (<a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;global, double scal_left, double scal_right)</td></tr>
<tr class="memdesc:aac8dd803bd3438778440824a5a376e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="#aac8dd803bd3438778440824a5a376e6e">More...</a><br /></td></tr>
<tr class="separator:aac8dd803bd3438778440824a5a376e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5093da7f2c37f905a9a748773aa2bb"><td class="memTemplParams" colspan="2">template&lt;class BinaryOp &gt; </td></tr>
<tr class="memitem:a2a5093da7f2c37f905a9a748773aa2bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html#a2a5093da7f2c37f905a9a748773aa2bb">evaluate</a> (BinaryOp f, unsigned plane=0) const </td></tr>
<tr class="memdesc:a2a5093da7f2c37f905a9a748773aa2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a 2d functor and transform to all planes along the fieldlines.  <a href="#a2a5093da7f2c37f905a9a748773aa2bb">More...</a><br /></td></tr>
<tr class="separator:a2a5093da7f2c37f905a9a748773aa2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e6e1e828d25dcf97fe794827fdc060"><td class="memTemplParams" colspan="2">template&lt;class BinaryOp , class UnaryOp &gt; </td></tr>
<tr class="memitem:a54e6e1e828d25dcf97fe794827fdc060"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html#a54e6e1e828d25dcf97fe794827fdc060">evaluate</a> (BinaryOp f, UnaryOp g, unsigned p0, unsigned rounds) const </td></tr>
<tr class="memdesc:a54e6e1e828d25dcf97fe794827fdc060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a 2d functor and transform to all planes along the fieldlines.  <a href="#a54e6e1e828d25dcf97fe794827fdc060">More...</a><br /></td></tr>
<tr class="separator:a54e6e1e828d25dcf97fe794827fdc060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3af364529543736c33b86f24e0db44b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html#ac3af364529543736c33b86f24e0db44b">einsPlus</a> (const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;in, <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;out)</td></tr>
<tr class="memdesc:ac3af364529543736c33b86f24e0db44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the interpolation to the next planes.  <a href="#ac3af364529543736c33b86f24e0db44b">More...</a><br /></td></tr>
<tr class="separator:ac3af364529543736c33b86f24e0db44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe026edb02d7a59379de90d1ab308684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html#afe026edb02d7a59379de90d1ab308684">einsMinus</a> (const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;in, <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;out)</td></tr>
<tr class="memdesc:afe026edb02d7a59379de90d1ab308684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the interpolation to the previous planes.  <a href="#afe026edb02d7a59379de90d1ab308684">More...</a><br /></td></tr>
<tr class="separator:afe026edb02d7a59379de90d1ab308684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7682fbb1c95526e0a4fa67c03ce631e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html#ae7682fbb1c95526e0a4fa67c03ce631e">einsPlusT</a> (const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;in, <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;out)</td></tr>
<tr class="memdesc:ae7682fbb1c95526e0a4fa67c03ce631e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the transposed interpolation to the previous plane.  <a href="#ae7682fbb1c95526e0a4fa67c03ce631e">More...</a><br /></td></tr>
<tr class="separator:ae7682fbb1c95526e0a4fa67c03ce631e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd80eca837c50fa2f148546c4041029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html#a1cd80eca837c50fa2f148546c4041029">einsMinusT</a> (const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;in, <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;out)</td></tr>
<tr class="memdesc:a1cd80eca837c50fa2f148546c4041029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the transposed interpolation to the next plane.  <a href="#a1cd80eca837c50fa2f148546c4041029">More...</a><br /></td></tr>
<tr class="separator:a1cd80eca837c50fa2f148546c4041029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b27922562618e04b631e450d22058b3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html#a7b27922562618e04b631e450d22058b3">hz</a> () const </td></tr>
<tr class="memdesc:a7b27922562618e04b631e450d22058b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">hz is the distance between the plus and minus planes  <a href="#a7b27922562618e04b631e450d22058b3">More...</a><br /></td></tr>
<tr class="separator:a7b27922562618e04b631e450d22058b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40f4ee40f5135c4fc37d84e82bd9529"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html#ad40f4ee40f5135c4fc37d84e82bd9529">hp</a> () const </td></tr>
<tr class="memdesc:ad40f4ee40f5135c4fc37d84e82bd9529"><td class="mdescLeft">&#160;</td><td class="mdescRight">hp is the distance between the plus and current planes  <a href="#ad40f4ee40f5135c4fc37d84e82bd9529">More...</a><br /></td></tr>
<tr class="separator:ad40f4ee40f5135c4fc37d84e82bd9529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b37ed57ac517960102a0111a68787e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html#a80b37ed57ac517960102a0111a68787e">hm</a> () const </td></tr>
<tr class="memdesc:a80b37ed57ac517960102a0111a68787e"><td class="mdescLeft">&#160;</td><td class="mdescRight">hm is the distance between the current and minus planes  <a href="#a80b37ed57ac517960102a0111a68787e">More...</a><br /></td></tr>
<tr class="separator:a80b37ed57ac517960102a0111a68787e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeec60a06ae03211c2eaae8d6c359589"><td class="memItemLeft" align="right" valign="top">const Geometry &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html#abeec60a06ae03211c2eaae8d6c359589">grid</a> () const </td></tr>
<tr class="memdesc:abeec60a06ae03211c2eaae8d6c359589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the underlying grid.  <a href="#abeec60a06ae03211c2eaae8d6c359589">More...</a><br /></td></tr>
<tr class="separator:abeec60a06ae03211c2eaae8d6c359589"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Geometry, class LocalMatrix, class Communicator, class LocalContainer&gt;<br />
struct dg::MPI_FieldAligned&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;</h3>

<p>Class for the evaluation of a parallel derivative (MPI Version) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LocalMatrix</td><td>The matrix class of the interpolation matrix </td></tr>
    <tr><td class="paramname">Communicator</td><td>The communicator used to exchange data in the RZ planes </td></tr>
    <tr><td class="paramname">LocalContainer</td><td>The container-class to on which the interpolation matrix operates on (does not need to be dg::HVec) </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a28ebee51e0decb692933a38363dca3f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class LocalMatrix , class Communicator , class LocalContainer &gt; </div>
<div class="memtemplate">
template&lt;class Field , class Limiter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html">dg::MPI_FieldAligned</a>&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;::<a class="el" href="structdg_1_1_m_p_i___field_aligned.html">MPI_FieldAligned</a> </td>
          <td>(</td>
          <td class="paramtype">Field&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Limiter&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="structdg_1_1_default_limiter.html">DefaultLimiter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>globalbcz</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deltaPhi</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a field and a grid. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Field</td><td>The Fieldlines to be integrated: Has to provide void operator()( const std::vector&lt;dg::HVec&gt;&amp;, std::vector&lt;dg::HVec&gt;&amp;) where the first index is R, the second Z and the last s (the length of the field line) </td></tr>
    <tr><td class="paramname">Limiter</td><td>Class that can be evaluated on a 2d grid, returns 1 if there is a limiter and 0 if there isn't. If a field line crosses the limiter in the plane \( \phi=0\) then the limiter boundary conditions apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>The field to integrate </td></tr>
    <tr><td class="paramname">grid</td><td>The grid on which to operate </td></tr>
    <tr><td class="paramname">eps</td><td>Desired accuracy of runge kutta </td></tr>
    <tr><td class="paramname">limit</td><td>Instance of the limiter class (Default is a limiter everywhere, note that if bcz is periodic it doesn't matter if there is a limiter or not) </td></tr>
    <tr><td class="paramname">globalbcz</td><td>Choose NEU or DIR. Defines BC in parallel on box </td></tr>
    <tr><td class="paramname">deltaPhi</td><td>Is either &lt;0 (then it's ignored), may differ from <a class="el" href="structdg_1_1_m_p_i___field_aligned.html#a7b27922562618e04b631e450d22058b3" title="hz is the distance between the plus and minus planes ">hz()</a> only if Nz() == 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If there is a limiter, the boundary condition is set by the bcz variable from the grid and can be changed by the set_boundaries function. If there is no limiter the boundary condition is periodic. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afe026edb02d7a59379de90d1ab308684"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class LocalMatrix , class Communicator , class LocalContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_m_p_i___field_aligned.html">dg::MPI_FieldAligned</a>&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;::einsMinus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the interpolation to the previous planes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input </td></tr>
    <tr><td class="paramname">out</td><td>output may not equal intpu </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1cd80eca837c50fa2f148546c4041029"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class LocalMatrix , class Communicator , class LocalContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_m_p_i___field_aligned.html">dg::MPI_FieldAligned</a>&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;::einsMinusT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the transposed interpolation to the next plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input </td></tr>
    <tr><td class="paramname">out</td><td>output may not equal intpu </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3af364529543736c33b86f24e0db44b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class LocalMatrix , class Communicator , class LocalContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_m_p_i___field_aligned.html">dg::MPI_FieldAligned</a>&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;::einsPlus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the interpolation to the next planes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input </td></tr>
    <tr><td class="paramname">out</td><td>output may not equal intpu </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7682fbb1c95526e0a4fa67c03ce631e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class LocalMatrix , class Communicator , class LocalContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_m_p_i___field_aligned.html">dg::MPI_FieldAligned</a>&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;::einsPlusT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the transposed interpolation to the previous plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input </td></tr>
    <tr><td class="paramname">out</td><td>output may not equal intpu </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a5093da7f2c37f905a9a748773aa2bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class LocalMatrix , class Communicator , class LocalContainer &gt; </div>
<div class="memtemplate">
template&lt;class BinaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt;LocalContainer&gt; <a class="el" href="structdg_1_1_m_p_i___field_aligned.html">dg::MPI_FieldAligned</a>&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>plane</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a 2d functor and transform to all planes along the fieldlines. </p>
<p>Evaluates the given functor on a 2d plane and then follows fieldlines to get the values in the 3rd dimension. Uses the grid given in the constructor. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinaryOp</td><td>Binary Functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor to evaluate </td></tr>
    <tr><td class="paramname">plane</td><td>The number of the plane to start</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an instance of container </dd></dl>

</div>
</div>
<a class="anchor" id="a54e6e1e828d25dcf97fe794827fdc060"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class LocalMatrix , class Communicator , class LocalContainer &gt; </div>
<div class="memtemplate">
template&lt;class BinaryOp , class UnaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt;LocalContainer&gt; <a class="el" href="structdg_1_1_m_p_i___field_aligned.html">dg::MPI_FieldAligned</a>&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOp&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a 2d functor and transform to all planes along the fieldlines. </p>
<p>Evaluates the given functor on a 2d plane and then follows fieldlines to get the values in the 3rd dimension. Uses the grid given in the constructor. The second functor is used to scale the values along the fieldlines. The fieldlines are assumed to be periodic. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinaryOp</td><td>Binary Functor </td></tr>
    <tr><td class="paramname">UnaryOp</td><td>Unary Functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor to evaluate in x-y </td></tr>
    <tr><td class="paramname">g</td><td>Functor to evaluate in z </td></tr>
    <tr><td class="paramname">p0</td><td>The number of the plane to start </td></tr>
    <tr><td class="paramname">rounds</td><td>The number of rounds to follow a fieldline</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an instance of container </dd></dl>

</div>
</div>
<a class="anchor" id="abeec60a06ae03211c2eaae8d6c359589"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class LocalMatrix , class Communicator , class LocalContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Geometry&amp; <a class="el" href="structdg_1_1_m_p_i___field_aligned.html">dg::MPI_FieldAligned</a>&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;::grid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the underlying grid. </p>
<dl class="section return"><dt>Returns</dt><dd>the grid </dd></dl>

</div>
</div>
<a class="anchor" id="a80b37ed57ac517960102a0111a68787e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class LocalMatrix , class Communicator , class LocalContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt;LocalContainer&gt;&amp; <a class="el" href="structdg_1_1_m_p_i___field_aligned.html">dg::MPI_FieldAligned</a>&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;::hm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>hm is the distance between the current and minus planes </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a class="anchor" id="ad40f4ee40f5135c4fc37d84e82bd9529"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class LocalMatrix , class Communicator , class LocalContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt;LocalContainer&gt;&amp; <a class="el" href="structdg_1_1_m_p_i___field_aligned.html">dg::MPI_FieldAligned</a>&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;::hp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>hp is the distance between the plus and current planes </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a class="anchor" id="a7b27922562618e04b631e450d22058b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class LocalMatrix , class Communicator , class LocalContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt;LocalContainer&gt;&amp; <a class="el" href="structdg_1_1_m_p_i___field_aligned.html">dg::MPI_FieldAligned</a>&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;::hz </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>hz is the distance between the plus and minus planes </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a class="anchor" id="ac82d1728dc5a9a86919dd2ec5f1f04bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class LocalMatrix , class Communicator , class LocalContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_m_p_i___field_aligned.html">dg::MPI_FieldAligned</a>&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions. </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">left</td><td>left boundary value </td></tr>
    <tr><td class="paramname">right</td><td>right boundary value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afedbdcbfbeaf5b1fd8635061451d5846"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class LocalMatrix , class Communicator , class LocalContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_m_p_i___field_aligned.html">dg::MPI_FieldAligned</a>&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions. </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">left</td><td>left boundary value </td></tr>
    <tr><td class="paramname">right</td><td>right boundary value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac8dd803bd3438778440824a5a376e6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class LocalMatrix , class Communicator , class LocalContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_m_p_i___field_aligned.html">dg::MPI_FieldAligned</a>&lt; Geometry, LocalMatrix, Communicator, LocalContainer &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; LocalContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scal_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scal_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">global</td><td>3D vector containing boundary values </td></tr>
    <tr><td class="paramname">scal_left</td><td>left scaling factor </td></tr>
    <tr><td class="paramname">scal_right</td><td>right scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/matthias/Projekte/feltor/inc/dg/geometry/<a class="el" href="mpi__fieldaligned_8h_source.html">mpi_fieldaligned.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1_m_p_i___field_aligned.html">MPI_FieldAligned</a></li>
    <li class="footer">Generated on Thu Jun 23 2016 12:05:44 for Discontinuous Galerkin Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
